#version 450 core

layout(location = 0) out vec4 color;

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct Light {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

    vec3 diffuse;
    vec3 specular;
    vec3 ambient;
};


in vec3 fragmentColor;
in vec3 fragmentNormal;
in vec3 fragPosition;
in vec2 fragmentUv;

uniform Material material;

uniform int numDirLights;
#define NR_DIR_LIGHTS 16
uniform Light directionalLights[NR_DIR_LIGHTS];

uniform int numPointLights;
#define NR_POINT_LIGHTS 32
uniform Light pointLights[NR_POINT_LIGHTS];

uniform vec3 cameraPosition;
uniform float alphaDiscard;

uniform vec2 u_colorSource;
uniform sampler2D textureSampler;
uniform sampler2D specularSampler;
uniform sampler2D normalSampler;


vec4 getAmbientColor() {
    float fromVertexColor = u_colorSource.x;
    float fromTextureColor = u_colorSource.y;

    vec4 fragVertexColor = fromVertexColor * vec4(fragmentColor, 1);
    vec4 fragTextureColor = fromTextureColor * texture(textureSampler, fragmentUv);

    //vec4 calculatedFragColor = vec4(fragmentColor, 1);
    vec4 calculatedFragColor = fragVertexColor + fragTextureColor;
    return calculatedFragColor;
}

vec4 trySample(vec4 sampled, vec3 option) {
    //return vec4(option, 1);
    if (length(sampled) > 0) {
        return sampled;
    } else {
        return vec4(option, 1);
    }
}

vec3 ComputeLight(Light light, float attenuation, 
   vec3 fragColor, vec3 normal, vec3 fragPosBumped, vec3 cameraToSurface, vec3 lightDir) {
   
    //ambient    
    vec3 ambient = light.ambient * fragColor;
    
    //diffuse
    float lightAngle = dot(normal, lightDir);
    float diffusion = max(lightAngle, 0.0);
    vec3 diffuse = diffusion * light.diffuse * fragColor;
   
    //specular
    vec3 surfaceToLight = -lightDir;
    vec3 lightReflection = reflect(surfaceToLight, normal); //https://learnopengl.com/img/lighting/basic_lighting_specular_theory.png
    //the smaller the angle, the more light hits the camera
    float angleFromCameraToReflection = max(dot(cameraToSurface, lightReflection), 0);
    vec3 actualSpecularLight = light.specular * float(int(material.shininess > 0));
    vec3 specularHighlight = vec3(trySample(texture(specularSampler, fragmentUv), material.specular));
    float specularFactor = pow(angleFromCameraToReflection, max(material.shininess, 1));
    vec3 specular = actualSpecularLight * specularFactor * specularHighlight;

    return ambient + diffuse * attenuation + specular * attenuation;
}

void main() {
    vec4 calculatedFragColor = getAmbientColor();
    if (calculatedFragColor.a < alphaDiscard) discard;
    //@TODO Bump mapping
    vec3 fragPosBumped = fragPosition;

    //compute the vector that points from fragPosBumped towards the camera
    //aka viewDir
    vec3 normal = normalize(fragmentNormal);
    vec3 cameraToSurface = normalize(cameraPosition - fragPosBumped);
    vec3 result = vec3(0,0,0);
    for (int i = 0; i < numDirLights; i++) {
        Light light = directionalLights[i];
        result += ComputeLight(
            light, 1.0, calculatedFragColor.xyz,
            normal, fragPosBumped, cameraToSurface,
            normalize(-light.position)           
        );
    }
    for (int i = 0; i < numPointLights; i++) {
        Light light = pointLights[i];
        float distance = length(light.position - fragPosBumped);
        float attenuation = 1.0 / 
            (light.constant + (light.linear * distance) + (light.quadratic * (distance * distance)));
        result += ComputeLight(
            light, attenuation, calculatedFragColor.xyz,
            normal, fragPosBumped, cameraToSurface,
            normalize(light.position - fragPosBumped)
        );
    }
    
    //distance from light to point
    color = vec4(result, 1);
}